""":class:`~isct.container.Container` implemementation for ``Docker``."""
import getpass
import logging
import os
import sys

from .container import Container
from .utilities import OS
from .runner import Logger


class Docker(Container):
    """Implements :class:`~isct.container.Container` for ``Docker``."""
    def __init__(self, path, docker_group=False, runner=Logger()):
        super().__init__(path, runner=runner)
        self.docker_group = docker_group
        self.bind_flag = '-v'

        # Docker requires `sudo` when no part of user group; only on Linux
        self.sudo = ''
        if not docker_group:
            if OS.from_platform(sys.platform) == OS.LINUX:
                self.sudo = 'sudo'

    def exists(self):
        """Returns ``True`` if the Docker container exists."""
        cmd = f'{self.sudo} docker image inspect {self.tag}'.split()
        return self.runner.run(cmd, check=True)

    def create(self):
        """Create a Docker container."""
        cmd = f'{self.sudo} docker build {self.path.absolute()} -t {self.tag}'
        return self.runner.run(cmd.split())

    def run(self, args=''):
        """Evaluate the Docker command.

        Depending on the hardware and system configuration, this command will
        run two commands. The first to evaluate the simulation and second to
        update possible file permissions of the emitted output files. Note,
        even when the simulation fails, it is still attempted to update the
        file permissions to reduce the change of leaving around files with the
        wrong permissions.
        """
        cmd = f'{self.sudo} docker run {self.volumes} {self.tag} {args}'
        success = self.runner.run(cmd.split(), check=True)

        if (cmd := self.update_file_permissions()) is None:
            return success

        changed_permissions = self.runner.run(cmd, check=True)
        if not changed_permissions:
            logging.critical('Failed to change file permissions.')

        return success and changed_permissions

    # FIXME: Ideally there would be no need to have an implementation available
    #        of the next routine. Unfortunately the file generated by the
    #        Docker containers do not have the "right" file permissions at the
    #        moment, which is "fixed" by the following routine. However, the
    #        way where we use---note "exploit" would fit better here---the
    #        container images to change the file paths is not really elegant.
    #        Although the Docker-based containers are supported on many
    #        platforms, we should emphasize the use of Singularity containers,
    #        as these avoid the file permission related problems all together.
    def update_file_permissions(self):
        """Update file permissions for files created within Docker on Linux.

        This routine aims to fix the file permissions for files generated
        within Docker containers, specifically when running on Linux-based
        operating systems on the host machine. The issue arises from the
        permissions set within the container, as all newly created files have
        root permissions (i.e. the permissions within the Docker environment).

        This creates a problem when the user on the host machine does *not*
        have root permissions as well. In this case, the user is *not* able to
        change the permissions of these newly created files, nor remove them
        from their system.

        This routine considers two scenarios:

        1. The host does have root permissions.
        2. The host does not have root permissions.

        In the first case, we evaluate a `chown` operation to reset the
        permissions from `root:root` back to `user:user`.

        In the second case, we apply some trickery: the Docker container is
        invoked another time to evaluate the `chown` operation where the
        permissions are set to match the original permissions of the volume
        on the host machine.
        """
        if OS.from_platform(sys.platform) != OS.LINUX:
            return None

        # If no volumes were written, no permissions have to be updated
        if len(self.bind_volumes) == 0:
            return None

        # FIXME: Resolve the hard coded paths to extract the patient or trial
        #        containers from. When using the conventions of `/trial` and
        #        `/patient` this will work, but  for any other approach the
        #        corresponding bind volume is not found...

        # This loops over all volumes bound to the current container to
        # identify a patient or trial container, i.e. the path on the host
        # system that was bound to the local path (i.e. within the file system
        # of the container itself) of `/patient` or `/trial`. It is this path
        # on the host system for which the file permissions need to be updated
        # after files were written there from within the Docker container.
        host_path = local_path = None
        for (host, local) in self.bind_volumes:
            if '/patient' in str(local) or '/trial' in str(local):
                host_path, local_path = host, local
                break

        assert host_path is not None or local_path is not None, \
            """Lacking a permission path to derive the file permissions from
            for the files generated by the simulation container."""

        if not self.docker_group:
            # Directly convert ownership of the files created by the container
            # to match the ownership of the current user. Within this branch,
            # the user has the right permissions to do so, and we can directly
            # update the file permissions.
            user = getpass.getuser()
            return f'sudo chown -R {user}:{user} {str(host_path)}'.split()

        # In the remaining situation, the user has permissions to run Docker,
        # as the user is part of the "docker group". However, there are no
        # permissions to use `sudo` to reset the file permissions. Thus, to
        # still reset these permissions, well call into the Docker container
        # again specifically to reset these file permissions. Thus, inside the
        # Docker container---with root permissions---we change the ownership
        # of all documents within `/patient/*` to match the ownership of
        # the actual `/patient` directory on the host system.
        #
        # Reference discussions at: https://stackoverflow.com/a/29584184

        stat = os.stat(host_path)
        user_id = stat.st_uid
        group_id = stat.st_gid

        cmd = f"docker run --entrypoint /bin/sh {self.volumes} {self.tag} -c"
        permissions = f"chown -R {user_id}:{group_id} {str(local_path)}"

        # The permission path should not be split as this command should be
        # passed as a full command into the container itself.
        return [*cmd.split(), permissions]
