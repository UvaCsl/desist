import pathlib
import os
import subprocess
import shutil

from easyvvuq.encoders import BaseEncoder
from easyvvuq.decoders import YAMLDecoder
from .patient import Patient


class ISCTEncoder(BaseEncoder, encoder_name="ISCTEncoder"):
    def __init__(self, template_fname, target_filename=None):
        # template patient directory, e.g. `/path/patient_000`
        if isinstance(template_fname, pathlib.PosixPath):
            template_fname = str(template_fname)

        self.template_fname = template_fname

        # target patient directory, `patient_000` in `/run_000/`
        self.target_filename = os.path.basename(self.template_fname)

    def encode(self, params={}, target_dir=''):
        """Encode the parameter files into a copy of the patient YAML."""

        # copy original patient directory and all its contents
        orig = pathlib.Path(self.template_fname).absolute()
        copy = pathlib.Path(target_dir).absolute()

        # TODO: replace directory copy by default functionality of EasyVVUQ by
        # wrapping our ISCTEncoder together with a directory encoder.

        # add "/." to copy contents including hidden directories
        subprocess.run(["cp", "-r", f"{str(orig)}/.", copy])

        # files to be reset/removed
        remove = ['clot_present', 'thrombectomy_outcome.txt']

        # directories to remove them from
        dirs = [copy]
        for p in ['baseline', 'stroke', 'treatment']:
            dirs.append(copy.joinpath(p))

        # travers directories and remove desired files
        for d in dirs:
            for f in filter(os.path.isfile, d.iterdir()):
                f = pathlib.Path(f)
                if f.name in remove:
                    os.remove(f)

        # load the template patient configuration
        patient = Patient.from_yaml(self.template_fname)

        # change its filename
        patient.dir = pathlib.Path(target_dir).absolute()

        # update parameters: this updates all parameters that are read from
        # either the `patient.yml` or the `congfig.xml`.

        # attempt: update only parameters that are already present, if not,
        # we either are inserting them, which might or might not be what we
        # want to do, or we should update them otherwise
        for k, v in params.items():
            if k in patient:
                patient[k] = v

        done = [k for k, _ in params.items() if k in patient]
        for k in done:
            del params[k]

        # all parameters located in `baseline/bf_sim/Model_parameters.txt`
        options = [
            "BLOOD_VISC",
            "StrokeVolume",
            "Density",
            "SystolePressure",
            "DiastolePressure",
        ]
        matches = [(k, v) for k, v in params.items() if k in options]

        # update the matches only
        for k, v in matches:

            # update the patient config with these parameters
            patient[k] = v

            # read in template parameters
            with open(copy.joinpath("tmp.txt"), "w") as outfile:
                with open(
                        orig.joinpath("baseline/bf_sim/Model_parameters.txt"),
                        "r") as config:
                    for line in config:
                        key = line.strip().split("=")[0]
                        if key == k:
                            outfile.write(f"{key}={patient[key]}\n")
                        else:
                            outfile.write(line)

            shutil.move(copy.joinpath("tmp.txt"),
                        orig.joinpath("baseline/bf_sim/Model_parameters.txt"))
            del params[k]

        # assert the `params` dictionary is empty, indicating that all the
        # parameters have been encoded towards a location
        assert params == {}

        # dump patient to yaml and xml
        patient.to_yaml()
        patient.to_xml()

    def _log_substitution_failure(self, exception):
        # TODO
        pass

    def get_restart_dict(self):
        # TODO: temporary to fill requirement of returning some dict
        return {
            "target_filename": self.target_filename,
            "template_fname": self.template_fname
        }

    def element_version(self):
        # TODO: temporary to fill required function
        return "0.1"


class ISCTDecoder(YAMLDecoder, decoder_name="ISCTDecoder"):
    """ISCTDecoder decodes the patient outcome from isct trials.

    Currently the implementation wraps a `YAMLDecoder` to extract the patient
    outcome from the `patient_outcome.yml` generated by the `patient-outcome`
    module.
    """
    def __init__(self,
                 target_filename='patient_outcome.yml',
                 output_columns=None):
        super().__init__(target_filename, output_columns)

    def sim_complete(self, run_info=None):
        """Returns True if the target file is present.

        When considering `patient_outcome.yml` as target file, the result of
        sim_complete coincides with an indication if the simulation was
        complete, as the file is only present afterwards.
        """
        assert run_info is not None, "No run information provided."
        return os.patoh.isfile(
            pathlib.Path(run_info['run_dir']).joinpath(self.target_filename))
